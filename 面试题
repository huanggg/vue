下面是部分问题：

第1题 谈谈变量提升
第2题 说说bind、call、apply的 区别？
          call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。apply 
          bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。
          猫.吃鱼.call(狗，鱼)
          狗就吃到鱼了
第3题 如何实现一个 bind 函数？  
第4题 请实现一个 call 函数
第5题 如何实现一个 apply 函数？
第6题 简单说下原型链？
         原型:
            每个函数都会默认有一个prototype属性，它是一个指针，指向此函数的原型对象。而构造函数作为一个函数
            同样拥有自己的原型对象，而通过构造函数生成的对象实例中，拥有一个_proto_ 属性，它指向构造函数的原型对象.
            我们把构造函数的原型对象称为对象实例的原型。
         原型链
            我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，一个对象
            无论什么时候，我们只要创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性
            这个属性对象指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constroctor（构造函数）属性  
            这个属性包含一个指向prototype属性所在函数的指针
            把这个有__proto__串起来的直到Object.prototype.__proto__为null的链叫做原型链。原型链实际上就是js中数据继承的继承链          
第7题 怎么判断对象类型？
            console.log(Object.prototype.toString.call("jerry"));//[object String]
            console.log(Object.prototype.toString.call(12));//[object Number]
            console.log(Object.prototype.toString.call(true));//[object Boolean]
            console.log(Object.prototype.toString.call(undefined));//[object Undefined]
            console.log(Object.prototype.toString.call(null));//[object Null]
            console.log(Object.prototype.toString.call({name: "jerry"}));//[object Object]
            console.log(Object.prototype.toString.call(function(){}));//[object Function]
            console.log(Object.prototype.toString.call([]));//[object Array]
            console.log(Object.prototype.toString.call(new Date));//[object Date]
            console.log(Object.prototype.toString.call(/\d/));//[object RegExp]
            function Person(){};
            console.log(Object.prototype.toString.call(new Person));//[object Object]
第8题 说说箭头函数的特点
            普通函数与箭头函数有个微小的不同点。 箭头函数没有自己的this值 ，其this值是通
            过继承其它传入对象而获得的,通常来说是上一级外部函数的 this 的指向。
            函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象
第9题 如何确定This指向
           1.以函数的形式调用时，this永远都是window
           2.以方法的形式调用时，this就是调用方法的那个对象
           3.以构造函数的形式调用时，this是新创建的那个对象
           4.通过call()或apply()改变函数执行环境的情况况下，this就会指向其他对象
第10题 async、await 的优缺点
              优点：
            1、async函数自带执行器，自动执行，无需next
            2、yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
            3、async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator
            async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果
第11题 generator 原理
            function* gen(arg){
              yield 2;
              yield arg;
            }
            let genHandle = gen(3);
            for(let i of genHandle){
              console.log(i);   // 依次打印：2，3
            }
            let genHandle2 = gen(4);
            console.log(genHandle2.next()); // { value: 2, done: false }  返回值可以作为下一个next()的入参
            console.log(genHandle2.next()); // { value: 4, done: false }
            console.log(genHandle2.next()); // { value: undefined, done: true }
第12题 对Promise的理解
         Promise 的 API
            三个状态：pending，fulfilled，or rejected
            Promise.resolve()
            Promise.reject()
            Promise.prototype.catch()
            Promise.prototype.finally()
            Promise.all()
            Promise.race(）
第13题 == 和 ===区别，什么情况用 ==
第14题 垃圾回收 
           1 标记回收
           2 引用回收
第15题 说说你对闭包的理解
           闭包是能够访问另一个函数作用域中变量的函数(这个“另外一个函数”，通常指的是包含闭包函数的外部函数)
           1 优点
            1 加强代码封装性，用于设计私有的方法与变量（例如jquery）
            2 为变量存储内存提供途径（在内存中维持了一个变量）
           2 缺点
            1 过多的使用闭包，可能导致内存泄露
第16题 基本数据类型和引⽤类型在存储上的差别
第17题 浏览器 Eventloop 和 Node 中的有什么区别
第18题 怎样理解setTimeout 执行误差
第19题 说说函数节流和防抖
第20题 数组降维
第21题 请实现一个深拷贝
第22题 typeof 于 instanceof 区别
第23题 cookie和localSrorage、session、indexDB 的区别
第24题 怎么判断页面是否加载完成？
第25题 说说 jsonp 原理
        Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取数据，即跨域读取数据。
        客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。
        客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。
        为了便于客户端使用数据，逐渐形成了一种非正式传输协议，也就是JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，
        这样客户端就可以随意定制自己的函数来自动处理返回数据了。
        ajax和jsonp本质上是完全不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。
第26题 说说你对Service worker的理解
第27题 说说浏览器缓存机制
第28题 怎样选择合适的缓存策略
第29题 说说重绘（Repaint）和回流（Reflow）
第30题 如何优化图片
第31题 页面首屏渲染性能优化方案有哪些
第32题 浏览器性能问题-使用 Webpack 优化项目
第33题 Babel 原理
第34题 介绍下React 生命周期
第35题 react setState 机制
第36题 Vue的 nextTick 原理
第37题 Vue 生命周期
第38题 Vue 双向绑定
第39题 v-model原理
第40题 watch 和 computed 的区别和运用的场景
第41题 Vue 的父子通信
第42题 简述路由原理
第43题 MVVM-脏数据检测
第44题 MVVM-数据劫持
第45题 React V16 生命周期函数用法
第46题 Vue 和 React 区别
第47题 介绍下虚拟 DOM，对虚拟 DOM 的理解
第48题 路由鉴权 (路由守卫)
      1:全局守卫
      2:路由守卫
      3:组件守卫
第49题 TCP 3次握手
第50题 TCP 拥塞控制
第51题 慢开始算法
第52题 拥塞避免算法
第53题 tcp 快速重传
第54题 TCP New Ren 改进后的快恢复
第55题 HTTPS 握手
第56题 从输入 URL 到页面加载全过程
第57题 HTTP 常用状态码 301 302 304 403
第58题 常见排序-冒泡排序
第59题 常见排序-插入排序
第60题 常见排序-选择排序
第61题 常见排序-归并排序
第62题 常见排序-快排
第63题 常见排序-堆排序
第64题 常见排序-系统自带排序实现
第65题 介绍下设计模式-工厂模式
第66题 介绍下设计模式-单例模式
第67题 介绍下设计模式-适配器模式
第68题 介绍下设计模式-装饰模式
第69题 介绍下设计模式-代理模式
第70题 介绍下设计模式-发布-订阅模式
第71题 Vue 响应式原理
第72题 实现一个new操作符
第73题 实现一个JSON.stringify
第74题 实现一个JSON.parse
第75题 手写一个继承
第76题 实现一个JS函数柯里化
第77题 请手写一个Promise(中高级必考)
第78题 手写防抖(Debouncing)和节流(Throttling)
第79题 实现一个instanceOf
第80题 实现一个私有变量
第81题 使用setTimeout代替setInterval进行间歇调用
第82题 数组中的forEach和map的区别
第83题 for in和for of的区别
第84题 写一个发布订阅 EventEmitter方法
第85题 let、var、const区别
第86题 typeof和instanceof 区别
第87题 常见的继承的几种方法
             方式一、原型链继承
             方式二: 借用构造函数继承  call apply
             方式三: 原型链+借用构造函数的组合继承
             方式三: ES6中class 的继承
             需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。
             class Person {
                  //调用类的构造方法
                  constructor(name, age) {
                      this.name = name
                      this.age = age
                  }
                  //定义一般的方法
                  showName() {
                      console.log("调用父类的方法")
                      console.log(this.name, this.age);
                  }
              }
              let p1 = new  Person('kobe', 39)
              console.log(p1)
              //定义一个子类
              class Student extends Person {
                  constructor(name, age, salary) {
                      super(name, age)//通过super调用父类的构造方法
                      this.salary = salary
                  }
                  showName() {//在子类自身定义方法
                      console.log("调用子类的方法")
                      console.log(this.name, this.age, this.salary);
                  }
              }
              let s1 = new Student('wade', 38, 1000000000)            
              s1.showName()
第88题 常见的浏览器内核有哪些?
第89题 浏览器的主要组成部分是什么？
第90题 浏览器是如何渲染UI的？
第91题 浏览器如何解析css选择器？
第92题 DOM Tree是如何构建的？
第93题 重绘与重排的区别？
        一旦渲染树构建完成，就要开始绘制（paint）页面元素了。当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，
        这个过程称为“重排”。完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘
        但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。
    重排触发机制
        添加或删除可见的DOM元素
        元素位置改变
        元素本身的尺寸发生改变
        内容改变
        页面渲染器初始化
        浏览器窗口大小发生改变
第94题 如何触发重排和重绘？
第95题 如何避免重绘或者重排？
第96题 前端如何实现即时通讯？
第97题 什么是浏览器同源策略？
        同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，
        如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
第98题 怎样解决跨域问题？
  跨域解决方案
        1、 通过jsonp跨域
        2、 document.domain + iframe跨域
        3、 location.hash + iframe
        4、 window.name + iframe跨域
        5、 postMessage跨域
        6、 跨域资源共享（CORS）
        7、 nginx代理跨域
        8、 nodejs中间件代理跨域
        9、 WebSocket协议跨域
第99题 时间格式化
第100题 说说对html 语义化的理解
第101题 说说常用的 meta 标签
第102题 说说两种盒模型以及区别
第103题 css reset 和 normalize.css 有什么区别
第104题 怎样让元素水平垂直居中
第105题 说说选择器的权重计算方式
第106题 清除浮动的方法
第107题 说说你对 BFC 的理解
第108题 import 和 link 区别
第109题 说下 [1, 2, 3].map(parseInt) 结果
第110题 介绍下浏览器事件委托
第111题 10w 条记录的数组，一次性渲染到页面上，如何处理可以不冻结UI？
第112题 如何实现一个左右固定，中间自适应的三栏布局
第113题 如何实现一个自适应的正方形
第114题 如何用css实现一个三角形
第115题 介绍下 positon 属性
第116题 说说渐进增强和优雅降级
第117题 defer和async区别
第118题 实现sleep函数
第119题 实现 lazyMan
第120题 获取元素的最终background-color
